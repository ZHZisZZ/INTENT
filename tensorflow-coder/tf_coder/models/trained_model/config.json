{
    "allow_restore": false,
    "batch_size": 1024,
    "beta": 1,
    "eval_batch_size": 100000,
    "eval_step_frequency": 100,
    "feedforward_size": 1024,
    "global_norm_clip": 5,
    "keep_checkpoint_every_n_hours": 0.5,
    "learning_rate": 0.0001,
    "log_device_placement": false,
    "loss": "f_beta",
    "max_num_inputs": 3,
    "max_rank": 4,
    "max_weight": 10000,
    "num_count_buckets": 21,
    "num_dtypes": 12,
    "num_epochs": 3,
    "num_feedforward_layers": 1,
    "num_float_buckets": 29,
    "num_kinds": 5,
    "num_ops": 134,
    "num_shape_buckets": 21,
    "operation_names": [
        "tf.abs(x)",
        "tf.add(x, y)",
        "tf.add_n(inputs)",
        "tf.argmax(input, axis)",
        "tf.argmin(input, axis)",
        "tf.argsort(values, axis, stable=True)",
        "tf.argsort(values, axis, direction='DESCENDING', stable=True)",
        "tf.boolean_mask(tensor, mask)",
        "tf.broadcast_to(input, shape)",
        "tf.cast(x, dtype)",
        "tf.clip_by_value(t, clip_value_min, clip_value_max)",
        "tf.concat(values, axis)",
        "tf.constant(value)",
        "tf.constant(value, dtype)",
        "tf.divide(x, y)",
        "tf.equal(x, y)",
        "tf.exp(x)",
        "tf.expand_dims(input, axis)",
        "tf.eye(num_rows)",
        "tf.eye(num_rows, num_columns)",
        "tf.eye(num_rows, dtype)",
        "tf.fill(dims, value)",
        "tf.gather(params, indices)",
        "tf.gather(params, indices, axis, batch_dims)",
        "tf.gather_nd(params, indices)",
        "tf.gather_nd(params, indices, batch_dims)",
        "tf.greater(x, y)",
        "tf.greater_equal(x, y)",
        "tf.math.bincount(arr)",
        "tf.math.ceil(x)",
        "tf.math.count_nonzero(input)",
        "tf.math.count_nonzero(input, axis)",
        "tf.math.cumsum(x, axis)",
        "tf.math.cumsum(x, axis, exclusive=True)",
        "tf.math.divide_no_nan(x, y)",
        "tf.math.floor(x)",
        "tf.math.log(x)",
        "tf.math.negative(x)",
        "tf.math.reciprocal(x)",
        "tf.math.reciprocal_no_nan(x)",
        "tf.math.segment_max(data, segment_ids)",
        "tf.math.segment_mean(data, segment_ids)",
        "tf.math.segment_min(data, segment_ids)",
        "tf.math.segment_prod(data, segment_ids)",
        "tf.math.segment_sum(data, segment_ids)",
        "tf.math.squared_difference(x, y)",
        "tf.math.top_k(input, k)",
        "tf.math.unsorted_segment_max(data, segment_ids, num_segments)",
        "tf.math.unsorted_segment_mean(data, segment_ids, num_segments)",
        "tf.math.unsorted_segment_min(data, segment_ids, num_segments)",
        "tf.math.unsorted_segment_prod(data, segment_ids, num_segments)",
        "tf.math.unsorted_segment_sum(data, segment_ids, num_segments)",
        "tf.matmul(a, b)",
        "tf.maximum(x, y)",
        "tf.minimum(x, y)",
        "tf.multiply(x, y)",
        "tf.not_equal(x, y)",
        "tf.one_hot(indices, depth)",
        "tf.ones(shape)",
        "tf.ones_like(input)",
        "tf.pad(tensor, paddings, mode='CONSTANT')",
        "tf.pad(tensor, paddings, mode='CONSTANT', constant_values)",
        "tf.pad(tensor, paddings, mode='REFLECT')",
        "tf.pad(tensor, paddings, mode='SYMMETRIC')",
        "tf.range(start)",
        "tf.range(start, limit, delta)",
        "tf.reduce_any(input_tensor, axis)",
        "tf.reduce_max(input_tensor)",
        "tf.reduce_max(input_tensor, axis)",
        "tf.reduce_mean(input_tensor)",
        "tf.reduce_mean(input_tensor, axis)",
        "tf.reduce_min(input_tensor)",
        "tf.reduce_min(input_tensor, axis)",
        "tf.reduce_prod(input_tensor, axis)",
        "tf.reduce_sum(input_tensor)",
        "tf.reduce_sum(input_tensor, axis)",
        "tf.reshape(tensor, shape)",
        "tf.reverse(tensor, axis)",
        "tf.roll(input, shift, axis)",
        "tf.round(x)",
        "tf.searchsorted(sorted_sequence, values, side='left')",
        "tf.searchsorted(sorted_sequence, values, side='right')",
        "tf.sequence_mask(lengths)",
        "tf.sequence_mask(lengths, maxlen)",
        "tf.shape(input)",
        "tf.sign(x)",
        "tf.sort(values, axis)",
        "tf.sort(values, axis, direction='DESCENDING')",
        "tf.sqrt(x)",
        "tf.square(x)",
        "tf.squeeze(input)",
        "tf.squeeze(input, axis)",
        "tf.stack(values, axis)",
        "tf.subtract(x, y)",
        "tf.tensordot(a, b, axes)",
        "tf.tile(input, multiples)",
        "tf.transpose(a)",
        "tf.transpose(a, perm)",
        "tf.unique_with_counts(x)",
        "tf.unstack(value, axis)",
        "tf.where(condition)",
        "tf.where(condition, x, y)",
        "tf.zeros(shape)",
        "tf.zeros_like(input)",
        "tf.SparseTensor(indices, values, dense_shape)",
        "tf.sparse.add(a, b)",
        "tf.sparse.concat(axis, sp_inputs)",
        "tf.sparse.expand_dims(sp_input, axis)",
        "tf.sparse.from_dense(tensor)",
        "tf.sparse.maximum(sp_a, sp_b)",
        "tf.sparse.minimum(sp_a, sp_b)",
        "tf.sparse.reduce_max(sp_input, axis, output_is_sparse)",
        "tf.sparse.reduce_sum(sp_input, axis, output_is_sparse)",
        "tf.sparse.reset_shape(sp_input)",
        "tf.sparse.reshape(sp_input, shape)",
        "tf.sparse.retain(sp_input, to_retain)",
        "tf.sparse.slice(sp_input, start, size)",
        "tf.sparse.split(sp_input, num_split, axis)",
        "tf.sparse.to_dense(sp_input)",
        "tf.sparse.to_dense(sp_input, default_value)",
        "tf.sparse.to_indicator(sp_input, vocab_size)",
        "tf.sparse.transpose(sp_input)",
        "tf.sparse.transpose(sp_input, perm)",
        "IndexingAxis1Operation",
        "IndexingOperation",
        "PairCreationOperation",
        "SingletonTupleCreationOperation",
        "SlicingAxis0BothOperation",
        "SlicingAxis0LeftOperation",
        "SlicingAxis0RightOperation",
        "SlicingAxis1BothOperation",
        "SlicingAxis1LeftOperation",
        "SlicingAxis1RightOperation",
        "TripleCreationOperation"
    ],
    "save_step_frequency": 100,
    "summary_step_frequency": 100,
    "weight_numerator": "max",
    "weighted_ops": true
}